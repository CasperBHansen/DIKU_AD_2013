%========== Heaps ==========%

\chapter{Heaps}
\label{ch:heaps}

\textbf{Pensum} 6 \cite{clrs} \\\\
\textbf{Assignments} 2-2 (counter example), 13-3 (tree relation) \\\\
\textbf{Algorithms} Heap-sort \\\\
\textbf{Keywords} Min- and maxheap, sorting, priority queues
\vspace{1in}

\noindent A heap is a nearly complete $n$-nary tree, we will concern ourselves
only with binary heaps - and as such, a binary heap is a nearly complete
binary tree. A heap implements a set $S$ of elements, in which each element
has an associated key. The actual structure of a heap is simply an array, and
so a heap is defined by the operations performed on the array, rather than the
data structure itself. The reason a heap is a tree-structure is a
visualization of the data, but not reflected by the data structure in any way.

Visualizing the array of a heap as a tree, we have that the root of the tree
corresponds to the first element of the array $i = 0$ (zero-indexed). The
parent of any node $n$ is given by $\lfloor n/2 \rfloor$. The children are
given by $2n$ and $2n + 1$, for left and right, respectively.

\newpage
\noindent Using the rules of traversal defined above, we can visualize the
array
\begin{figure}[H]
	\center
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
		\hline 16 & 14 & 10 & 8 & 7 & 9 & 3 & 2 & 4 & 1 \\ \hline
	\end{tabular}
	\caption{Example of a (binary-)heap}
	\label{fig:heap-array}
\end{figure}
as a tree-structure, as shown in the following figure.
\begin{figure}[H]
	\center
	\begin{tikzpicture}
	[
	scale=1.0,
	align=center,
	every node/.style={circle, fill=white, draw=black}
	]
		% level 1
		\node (n1) at 	(3.5, -1) {16};
		
		% level 2
		\node (n2) at 	(1.5, -2) {14};
		\node (n3) at 	(5.5, -2) {10};
		
		% level 3
		\node (n4) at 	(0.5, -3) {8};
		\node (n5) at 	(2.5, -3) {7};
		\node (n6) at 	(4.5, -3) {9};
		\node (n7) at 	(6.5, -3) {3};
		
		% level 4
		\node (n8) at 	(0, -4) {2};
		\node (n9) at 	(1, -4) {4};
		\node (n10) at 	(2, -4) {1};
		% \node (n11) at 	(3, -4) {11};
		% \node (n12) at 	(4, -4) {12};
		% \node (n13) at 	(5, -4) {13};
		% \node (n14) at 	(6, -4) {14};
		% \node (n15) at 	(7, -4) {15};
		
		% drawing code
		\foreach \from/\to in {n1/n2,n1/n3} \draw (\from) -- (\to);
		\foreach \from/\to in {n2/n4,n2/n5,n3/n6,n3/n7} \draw (\from) -- (\to);
		\foreach \from/\to in {n4/n8,n4/n9,n5/n10} \draw (\from) -- (\to);
	\end{tikzpicture}
	\caption{Example of a (binary-)heap visualized as a tree}
	\label{fig:heap-tree}
\end{figure}

\section{Priority Queues}
\label{ch:heaps|sub:priorityqueues}
A priority queue is an abstract data structure, which sorts and maintains a
set of data in such a way, that the data is prioritized. It is an important
distinction to make that a priority queue isn't a particular data structure,
but rather a class of data structures. Data structures that work well with
this notion include stacks, heaps, self-organizing lists, etc. We will focus
mainly on heaps.

A heap, however, is not a priority queue in and of itself, it must adhere to
a set of properties, and that is either the max- or min-heap properties.
\begin{description}
	\item \textbf{Max-heap} The key of a node is greater than or equal to the
keys of its children.
	\item \textbf{Min-heap} The key of a node is less than or equal to the
keys of its children.
\end{description}
As the max- and min heaps are defined by the procedures performed on them, we
must show that the their property is maintained by each of these procedures.

\begin{algorithm}[H]
	\caption{Max-heapify}
	\label{alg:max-heapify}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{MaxHeapify}{MaxHeapify}
	\SetKwFunction{Left}{Left}
	\SetKwFunction{Right}{Right}
	
	\Input{An array $A$ and index $i$}
	\Output{In-place swapping max-heap property violations of $A$.}
	
	\BlankLine
	\MaxHeapify($A$, $i$) \\
	\Begin
	{
		$l = $ \Left($i$) \\
		$r = $ \Right($i$) \\
		$largest = i$ \\
		\If{$l \leq A.size $ \textnormal{and} $A[l] > A[i]$}
		{
			$largest = l$ \\
		}
		\If{$r \leq A.size $ \textnormal{and} $A[r] > A[largest]$}
		{
			$largest = l$ \\
		}
		\If{$largest \neq i$}
		{
			Swap $A[i]$ and $A[largest]$ \\
			\MaxHeapify($A$, $largest$)
		}
	}
\end{algorithm}
Obviously, this function can easily be changed to \textit{min-heapify}, simply
by exchanging the conditional statements of $\leq$ with $\geq$, and likewise
$>$ to $<$. The procedure looks for a violation of the max-heap property,
restoring it by correcting that particular instance and check for further
violations on the corrected index.

Assuming the worst case, where the subproblem size is $2n/3$ we get the
recurrence $T(n) \leq T(2n/3) + \Theta(1)$, which by the master theorem (see
section \ref{eqn:master-theorem}) gives us $T(n) = O(\lg n)$, which
conveniently translates to the height of a tree - so for a given node $i$, we
at most correct a \textit{simple path} of the tree, or we can visualize it as
the violating node travels only in a downward path.

% possibly shorten the above, making space for explanation of the next
% algorithm, such that maybe we can have it all on one page.

\begin{algorithm}[H]
	\caption{Build max-heap}
	\label{alg:build-max-heap}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\SetKwInOut{Invariant}{Invariant}
	
	\SetKwFunction{BuildMaxHeap}{BuildMaxHeap}
	\SetKwFunction{MaxHeapify}{MaxHeapify}
	
	\SetKw{DownTo}{ down to }
	
	\Input{An array $A$}
	\Output{In-place heapifying the array $A$.}
	\Invariant{At the start of each iteration, each node $i+1, i+2, \dots, n$
is the root of a max-heap.}
	
	\BlankLine
	\BuildMaxHeap($A$) \\
	\Begin
	{
		$A.size = A.length$ \\
		\For{$i = \lfloor A.length/2 \rfloor \DownTo 1$}
		{
			\MaxHeapify($A$, $i$)
		}
	}
\end{algorithm}
\noindent \textbf{Initialization} \\
Prior to the first iteration of the loop, $i = \lfloor n/2 \rfloor$. Each node
$\lfloor n/2 \rfloor + 1 \lfloor n/2 \rfloor + 2, \dots n$ is a leaf and is
thus the root of a trivial max-heap.
\\\\
\noindent \textbf{Maintenance} \\
Both children of node $i$ are higher than $i$, by the loop invariant, they are
then both roots of max-heaps. As we call \texttt{MaxHeapify} it correct any
violations of the max-heap property of these. Hence we are building levels of
the max-heap in a bottom-up fashion.
\\\\
\noindent \textbf{Termination} \\
At termination $i = 0$. By the loop invariant, each node $1, 2, \dots, n$ is
the root of a max-heap - in particular, node $1$ is.
\\\\
The initialization part of the algorithm on lines 1-3 take constant time
$\Theta(1)$, and since we call \texttt{MaxHeapify} $n/2$ times, we must have
that \texttt{BuildMaxHeap} is upper-bounded by $O(n \lg n)$.

We can tighten this bound by observing that \texttt{MaxHeapify} is dependent
on the height $h = \lfloor \lg n \rfloor$, and has at most $\lceil n/2^{h+1}
\rceil$ nodes.

[... continue later, break...]

\newpage

\section{Procedures}
\label{ch:heaps|sec:procedures}
These are the procedures that are supported by max- or min-heaps.

\subsection{Insertion}
\label{ch:heaps|sec:procedures|sub:insertion}
...

% TODO: pseudo-code, complexity

\subsection{Extraction}
\label{ch:heaps|sec:procedures|sub:extraction}
When we want to extract an element out of a heap, because of its practical use
we are typically interested only in the root node. Getting the root node is a
trivial problem, we simply return the element at index zero - for a max-heap,
this would be the element with the largest key in the set, vice versa for a
min-heap.

\begin{algorithm}[H]
	\caption{Extract max}
	\label{alg:heap-extract-max}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKw{Error}{error}
	
	\SetKwFunction{ExtractMax}{ExtractMax}
	\SetKwFunction{MaxHeapify}{MaxHeapify}
	
	\Input{A heap $A$.}
	\Output{Returns the maximum of a heap, removing it from the heap.}
	
	\BlankLine
	\ExtractMax($A$) \\
	\Begin
	{
		\If{$A.size < 1$}{ \Error "Heap underflow." }
		$max = A[1]$ \\
		$A[1] = A[A.size]$ \\
		$A.size = A.size - 1$ \\
		\MaxHeapify($A$, 1) \\
		\Return $max$
	}
\end{algorithm}

\subsection{Increase key}
\label{ch:heaps|sec:procedures|sub:increase-key}
...

% TODO: pseudo-code, complexity

% TODO: prove that all procedures maintain the max- or min-heap property

\section{Sorting}
Given that the procedure for extraction, as defined in section
\ref{ch:heaps|sec:procedures|sub:extraction}, one can easily imagine that
building a max- or min-heap and emptying the priority queue by repeatedly
calling the extraction procedure on it produces a sorted array.

\begin{algorithm}[H]
	\caption{Heapsort}
	\label{alg:heapsort}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{HeapSort}{HeapSort}
	\SetKwFunction{BuildMaxHeap}{BuildMaxHeap}
	\SetKwFunction{MaxHeapify}{MaxHeapify}
	
	\SetKw{DownTo}{ down to }
	
	\Input{An unordered array $A$}
	\Output{In-place sorting of the array $A$.}
	
	\BlankLine
	\HeapSort($A$) \\
	\Begin
	{
		\BuildMaxHeap($A$) \\
		\For{$i = A.length \DownTo 2$}
		{
			Exchange $A[1]$ with $A[i]$ \\
			$A.size = A.size - 1$ \\
			\MaxHeapify($A$, 1)
		}
	}
\end{algorithm}

