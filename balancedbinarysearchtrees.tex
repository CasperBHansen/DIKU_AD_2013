%========== Balanced Binary Search Trees ==========%

\chapter{Balanced Binary Search Trees}
\label{ch:balancedbinarysearchtrees}

\textbf{Pensum} 12 + 13 \cite{clrs} \\\\
\textbf{Relevant Assignment} 13-3 \\\\
\textbf{Algorithms} Red-black tree, AVL-tree \\\\
\textbf{Keywords} ADT, BST structure- and property, rebalance, rotation
\vspace{1in}

\noindent A binary search tree is a node-based data structure that uses
pointers to keep the structure of a a set of nodes intact. Since the data
structure is purely held together by pointers, performing alterations on it
is very fast.
\\\\
\noindent \textbf{Structure} \\
Each node holds a $key$ and three pointers; one for each child-node, $left$
and $right$, and one for its parent-node $p$.
\\\\
\noindent \textbf{Property} \\
Let $x$ be a node in a binary search tree. If $y$ is a node in the left
subtree of $x$, then $y.key \leq x.key$. If $y$ is a node in the right
subtree of $x$, then $y.key \geq x.key$.

\newpage
\section{Operations}
Here we give the common operations performed on binary search trees.

\subsection{Searching}
Given the structure of a binary search tree, searching for a particular entry
is at most $O(\lg n)$, assuming that the tree is balanced. Should the tree not
be balanced the worst-case scenario is that the tree only has left- or right-
hand side children, which then produces a list, and searching a list takes
linear time $O(n)$. More specifically it is $O(h)$, where $h$ is the height.

\subsection{Minimum and Maximum}
The minimum and maximum procedures are simply search queries that looks only
to the left or right, in the cases of minimum and maximum, respectively. As
such, their running-time is the same as that of searching, $O(h)$.

% \subsection{Predecessor}
% ...

% \subsection{Successor}
% ...

\subsection{Insertion}
Inserting a node into a binary search tree is quite simple; we search through
the tree as usual until we find the spot where the node belongs. Since
everything else in this procedure is done in constant time $\Theta(1)$, and
all we are really doing is searching through the tree then it follows from the
search procedure that the running-time must be $O(h)$.

\subsection{Deletion}
The procedure of deleting a note $Z$ from a tree $T$ has 3 basic cases:

\begin{enumerate}
\item{If $Z$ has no children, we simply delete the node.}
\item{If $Z$ has 1 chils we elevate this child to $Z$'s postion and remove $Z$.}
\item{If $Z$ has 2 children, we find the sucessor $Y$, as $Z$'s right child. we put $Y$ in $Z$ place and make $Z$ left subtree the new left subtree of $Y$.
$Y$'s subtree is then used as right subtree, and is constructed recursivly as stated in this case}
\end{enumerate}

\subsection{Rotation}
There are two forms of rotation; left- and right-rotation. These are simply
pointer manipulations of the immediate nodes.
\begin{figure}[H]
	\center
	\begin{tikzpicture}
	[
	scale=1.0,
	align=center,
	empty/.style={},
	node/.style={circle, fill=white, draw=black},
	leaf/.style={circle, fill=white}
	]
		% transition
		\draw [->, dotted] (4, 2) -- node [above] {\small \texttt{RightRotate($T$, $y$)}} (6, 2);
		\draw [<-, dotted] (4, 0) -- node [above] {\small \texttt{LeftRotate($T$, $x$)}} (6, 0);
		
		% left
		\node (le) [empty] at 	(2, 3) {};
		
		\node (ly) [node] at 	(2, 2) {$y$};
		\node (lx) [node] at	(1, 1) {$x$};
		
		\node (la) [leaf] at 	(0, 0) {$\alpha$};
		\node (lb) [leaf] at 	(2, 0) {$\beta$};
		\node (lc) [leaf] at 	(3, 1) {$\gamma$};
	
		% right
		\node (re) [empty] at 	(8, 3) {};
		
		\node (ry) [node] at 	(9, 1) {$y$};
		\node (rx) [node] at	(8, 2) {$x$};
		
		\node (ra) [leaf] at 	(7, 1) {$\alpha$};
		\node (rb) [leaf] at 	(8, 0) {$\beta$};
		\node (rc) [leaf] at 	(10, 0) {$\gamma$};	
		% drawing code
		\foreach \from/\to in {le/ly,ly/lx,lx/la,lx/lb,ly/lc} \draw (\from) -- (\to);
		\foreach \from/\to in {re/rx,rx/ra,rx/ry,ry/rb,ry/rc} \draw (\from) -- (\to);
	\end{tikzpicture}
	\caption{Left- and right BST rotations}
	\label{fig:bst-rotations}
\end{figure}
Since all we are doing is to change a few pointers, the procedure takes
constant time $\Theta(1)$.

\section{Rebalancing}
When we use a balanced implementation of binary search trees, such as
\textit{red-black}- or \textit{AVL}-trees, we must maintain certain
properties, which are typically accounted for after applying an alteration on
the tree - this is called \textit{rebalancing} - whenever a tree gets
unbalanced, as the result of an operation performed on it, we say that the
tree is \textit{left- or right heavy}.

% TODO: write up cases for unbalanced trees, and how to fix them up.

\newpage
\section{Red-Black Binary Search Tree}
A red-black BST is a implementation of balanced binary search trees, and it
works by figuratively coloring each node in the tree one of two colors; red or
black. By the use of constraints on these colorings, and taking action
whenever we have a violation of the constraints, we can ensure that the tree
remains balanced --- hence also a minimum tree height, which in turn, also
gives us good performance.

\subsection{Properties}
These are the properties of red-back binary search trees.
\begin{enumerate}
	\item Every node is either red or black.
	\item The root is black.
	\item All leaves (\texttt{NIL}) are black.
	\item Both children of red nodes are black.
	\item All simple paths from a node to descendants leaves contain the same
number of black nodes.
\end{enumerate}


