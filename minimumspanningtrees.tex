%========== Minimum Spanning Trees ==========%

\chapter{Minimum Spanning Trees}
\label{ch:minimumspanningtrees}

\textbf{Pensum} 23 \cite{clrs} \\\\
\textbf{Assignments} 13-3 \\\\
\textbf{Algorithms} Kruskal's algorithm, Prim's algorithm \\\\
\textbf{Keywords} Greedy, optimal substructure, light edges,
binary- and fibonacci-heap
\vspace{1in}

\noindent A minimum spanning tree $T$ is a is a tree or graph whose edges are
a subset $T \subseteq E$ of a weighted graph $G = (V, E)$, with weight
function $w$, such that the weight of an edge $(u, v) \in E$ is determined by
$w$, and the weight of the tree $T$ is minimized.

The total weight of a graph $T$ is given by the sum of all of its edge weights.
\begin{align}
	w(T) = \sum_{(u, v) \in T}w(u, v)
\end{align}

The term \textit{spanning} refers to the fact that the tree $T$ spans the
entire set of vertices $V$, and the term \textit{minimum} refers to that the
tree $T$ is of minimum weight.
\section{Definitions}
These are the definitions specific to the minimum spanning tree problem.
\begin{description}
	\item A \textbf{cut} $(S, V-S)$ of an undirected graph $G = (V, E)$ is a
partition of $V$.
	\item A \textbf{crossing} is an edge $(u, v) \in E$ that \textit{crosses}
the cut $(S, V - S)$ --- that is, the edges end-points are in $S$ and $S - V$,
respectively.
	\item An cut \textbf{respects} a set $A$ of edges if no edges in $A$
crosses the cut.
	\item A \textbf{light edge} is an edge that crosses a cut and is of
minimum weight (see theorem 23.1\cite[p. 626]{clrs}).
\end{description}

\section{Optimal Substructure}
...

\section{Overlapping Subproblems}
...
% TODO: prove that removing an edge (u, v) yields two separate trees.

\newpage
\section{Generic Minimum Spanning Tree}
% p. 626, CLRS
The algorithm given below for finding the minimum spanning tree is a
generalization, meaning that it is somewhat loosely defined. As such, this
is merely a template for building an actual algorithm.
\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{GenericMST}{GenericMST}
	
	\Input{A graph $G = (V, E)$ and a weight function $w$ defined on $E$.}
	\Output{A minimum spanning tree of $G$.}
	
	\BlankLine
	
	\GenericMST($G$, $w$) \\
	\Begin
	{
		$A = \emptyset$ \\
		\While{$A$ \textnormal{does not form a spanning tree}}
		{
			find an edge $(u, v)$ that is safe for $A$ \\
			$A = A \cup \{(u, v)\}$
		}
	}
	
	\caption{GenericMST}
	\label{alg:generic-mst}
\end{algorithm}
\subsection{Loop Invariant}
We state the loop invariant of algorithm \ref{alg:generic-mst}; prior to each
iteration, $A$ is a subset of some minimum spanning tree.
\\\\
\noindent \textbf{Initialization} \\
After line 3, where we initialize the set $A$ to the empty set, $A$ trivially
satisfies the loop invariant, as the empty set is a subset of any set.
\\\\
\noindent \textbf{Maintenance} \\
Lines 4-7 maintains the loop invariant, because we only add \textit{safe}
edges to $A$. That is, edges $(u, v)$ where $A \cup \{(u, v)\}$ also
satisfies the loop invariant.
\\\\
\noindent \textbf{Termination} \\
Since all edges added to $A$ are in a minimum spanning tree, $A$ must be a
minimum spanning tree of $G$.

\newpage
\section{Kruskal's Algorithm}
% p. 631
... \\
\begin{algorithm}[H]
	\caption{Kruskal's algorithm}
	\label{alg:kruskal-mst}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{KruskalMST}{KruskalMST}
	\SetKwFunction{MakeSet}{MakeSet}
	\SetKwFunction{FindSet}{FindSet}
	\SetKwFunction{Union}{Union}
	
	\Input{A graph $G$ and a weight function $w$.}
	\Output{...}
	
	\BlankLine
	\KruskalMST($G$, $w$) \\
	\Begin
	{
		% initialization O(V)
		$A = \emptyset$ \\
		\For{\textnormal{each vertex } $v \in G.V$}
		{
			\MakeSet($v$)
		}
		Sort the edges of $G.E$ into nondecreasing order by weight $w$ \\
		
		% maintenance
		\For{\textnormal{each edge } $(u, v) \in G.E$}
		{
			\If{\FindSet$(u)$ $\neq$ \FindSet$(v)$}
			{
				$A = A \cup \{(u, v)\}$ \\
				\Union($u$, $v$)
			}
		}
	}
\end{algorithm}{\ }\\\\
In the above algorithm, we have assumed access to a number of utility
functions. These are explained below, and their complexity reasoned.
\begin{description}
	\item \texttt{MakeSet} creates a new set whose only member (and thus
representative) is $x$ --- takes $\Theta(1)$-time.
	\item \texttt{FindSet} returns a pointer to the representative of the
(unique) set containing $x$ --- takes $\Theta(1)$-time.
	\item \texttt{Union} ... --- takes ?.
\end{description}

\newpage
\subsection{Analysis}
The running-time of \ref{alg:kruskal-mst} depends on the implementation of
the disjoint-set data structure. Assuming the use of the fastest
implementation known (disjoint-set-forest, see section
21.3\cite[p. 568]{clrs}), the running-time is as follows.

The initialization occurs on lines 3--7. Line 3 takes constant time
$\Theta(1)$, lines 4--6 performs $|V|$ \texttt{MakeSet} operations. We can
sort the edges $G.E$ in $O(E \lg E)$-time.

The loop on lines 8--13 performs $O(E)$ \texttt{FindSet}- and \texttt{Union}
operations giving us grand a total of $O((V+E) \alpha(V))$, where $\alpha$
is a slowly growing function (see section 21.4\cite[p. 573]{clrs}).

\newpage
\section{Prim's Algorithm}
% p. 634
This algorithm relies on a priority queue (see section
\ref{ch:heaps|sub:priorityqueues} on page \pageref{ch:heaps|sub:priorityqueues}
for more on this topic).
\\\\
\begin{algorithm}[H]
	\caption{Prim's algorithm}
	\label{alg:prim-mst}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{PrimMST}{PrimMST}
	\SetKwFunction{ExtractMin}{ExtractMin}
	
	\SetKw{Nil}{NIL}
	
	\Input{A graph $G$, a weight function $w$ and an arbitrary root $r$.}
	\Output{In-place minimized spanning tree of $G$.}
	
	\BlankLine
	\PrimMST($G$, $w$, $r$) \\
	\Begin
	{
		% initialization O(V)
		\For{$u \in G.V$}
		{
			$u.key = \infty$ \\
			$u.\pi = $ \Nil
		}
		$r.key = 0$ \\
		$Q = G.V$ \\
		
		% ... O(?)
		\While{$Q \neq \emptyset$}
		{
			$u = \ExtractMin(Q)$ \\
			\For{$v \in G.Adj[u]$}
			{
				\If{$v \in Q$ \textnormal{and} $w(u, v) < v.key$}
				{
					$v.\pi = u$ \\
					$v.key = w(u, v)$
				}
			}
		}
	}
\end{algorithm}
If we relate it to algorithm \ref{alg:generic-mst} we see that for Prim's
algorithm the exit condition of forming a spanning tree takes the form of
emptying a priority queue.

\newpage
\subsection{Analysis}
...
