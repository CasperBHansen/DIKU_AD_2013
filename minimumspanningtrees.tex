%========== Minimum Spanning Trees ==========%

\chapter{Minimum Spanning Trees}
\label{ch:minimumspanningtrees}

\textbf{Pensum} 23 \cite{clrs} \\\\
\textbf{Assignments} 13-3 \\\\
\textbf{Algorithms} Kruskal's, Prim's\\\\
\textbf{Keywords} Greedy, optimal substructure, representation invariant,
binary- and fibonacci-heap
\vspace{1in}

\noindent A minimum spanning tree $T$ is a is a tree or graph whose edges are
a subset $T \subseteq E$ of a weighted graph $G = (V, E)$, with weight
function $w$, such that the weight of an edge $(u, v) \in E$ is determined by
$w$, and the weight of the tree $T$ is minimized.

The total weight of a graph $T$ is given by the sum of all of its edge weights.
\begin{align}
	w(T) = \sum_{(u, v) \in T}w(u, v)
\end{align}

The term \textit{spanning} refers to the fact that the tree $T$ spans the
entire set of vertices $V$, and the term \textit{minimum} refers to that the
tree $T$ is of minimum weight.

\section{Optimal Substructure}
...

\section{Overlapping Subproblems}
...
% TODO: prove that removing an edge (u, v) yields two separate trees.

\newpage
\section{Generic Minimum Spanning Tree}
% p. 626, CLRS
The algorithm given below for finding the minimum spanning tree is a
generalization, meaning that it is somewhat loosely defined. As such, this
is merely a template for building an actual algorithm.
\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{GenericMST}{GenericMST}
	
	\Input{A graph $G = (V, E)$ and a weight function $w$ defined on $E$.}
	\Output{A minimum spanning tree of $G$.}
	
	\BlankLine
	
	\GenericMST($G$, $w$) \\
	\Begin
	{
		$A = \emptyset$ \\
		\While{$A$ \textnormal{does not form a spanning tree}}
		{
			find an edge $(u, v)$ that is safe for $A$ \\
			$A = A \cup \{(u, v)\}$
		}
	}
	
	\caption{GenericMST}
	\label{alg:generic-mst}
\end{algorithm}
\subsection{Loop Invariant}
We state the loop invariant of algorithm \ref{alg:generic-mst}; prior to each
iteration, $A$ is a subset of some minimum spanning tree.
\\\\
\noindent \textbf{Initialization} \\
After line 3, where we initialize the set $A$ to the empty set, $A$ trivially
satisfies the loop invariant, as the empty set is a subset of any set.
\\\\
\noindent \textbf{Maintenance} \\
Lines 4-7 maintains the loop invariant, because we only add \textit{safe}
edges to $A$. That is, edges $(u, v)$ where $A \cup \{(u, v)\}$ also
satisfies the loop invariant.
\\\\
\noindent \textbf{Termination} \\
Since all edges added to $A$ are in a minimum spanning tree, $A$ must be a
minimum spanning tree of $G$.

\newpage
\section{Kruskal's Algorithm}
% p. 631
...

% TODO: pseudo-code

\newpage
\section{Prim's Algorithm}
% p. 634
This algorithm relies on a priority queue (see section
\ref{ch:heaps|sub:priorityqueues} on page \pageref{ch:heaps|sub:priorityqueues}
for more on this topic).
\\\\
\begin{algorithm}[H]
	\caption{Prim's algorithm}
	\label{alg:prim-mst}
	
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	
	\SetKwFunction{PrimMST}{PrimMST}
	\SetKwFunction{ExtractMin}{ExtractMin}
	
	\SetKw{Nil}{NIL}
	
	\Input{A graph $G$, a weight function $w$ and an arbitrary root $r$.}
	\Output{In-place minimized spanning tree of $G$.}
	
	\BlankLine
	\PrimMST($G$, $w$, $r$) \\
	\Begin
	{
		% initialization O(V)
		\For{$u \in G.V$}
		{
			$u.key = \infty$ \\
			$u.\pi = $ \Nil
		}
		$r.key = 0$ \\
		$Q = G.V$ \\
		
		% ... O(?)
		\While{$Q \neq \emptyset$}
		{
			$u = \ExtractMin(Q)$ \\
			\For{$v \in G.Adj[u]$}
			{
				\If{$v \in Q$ \textnormal{and} $w(u, v) < v.key$}
				{
					$v.\pi = u$ \\
					$v.key = w(u, v)$
				}
			}
		}
	}
\end{algorithm}
If we relate it to algorithm \ref{alg:generic-mst} we see that for Prim's
algorithm the exit condition of forming a spanning tree takes the form of
emptying a priority queue.

